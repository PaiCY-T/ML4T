---
epic: ML4T-Alpha
task_number: 5
title: Enhanced Backtesting Framework
description: Implement robust backtesting engine with walk-forward analysis, regime-aware performance attribution, and realistic transaction cost modeling for Taiwan market
status: pending
created: 2025-09-23T08:10:00Z
updated: 2025-09-23T08:10:00Z
assignee: null
depends_on: [1, 2, 3, 4]
parallel: false
layer: 2
size: L
estimated_hours: 60
---

# Task 5: Enhanced Backtesting Framework

## Overview

Build a comprehensive backtesting engine that integrates all Layer 1 components (regime detection, dynamic position sizing, enhanced factors, multi-regime strategy) with sophisticated analysis capabilities including walk-forward validation, regime-aware performance attribution, and Taiwan market-specific transaction cost modeling.

## Objectives

- **Primary**: Implement walk-forward analysis with >95% accuracy vs live trading
- **Secondary**: Add regime-aware performance attribution and analysis
- **Tertiary**: Model realistic Taiwan market transaction costs and constraints

## Technical Requirements

### Core Backtesting Engine

**Walk-Forward Analysis Framework**
```python
# Rolling window backtesting with out-of-sample validation
def walk_forward_backtest(start_date, end_date, train_window=252*3, test_window=252):
    """
    3-year training window, 1-year testing window
    Roll forward monthly for robust out-of-sample validation
    """
    training_period = train_window  # 3 years
    testing_period = test_window    # 1 year
    step_size = 21  # Monthly roll-forward

    results = []
    for window_start in date_range(start_date, end_date, step_size):
        train_start = window_start
        train_end = train_start + training_period
        test_start = train_end + 1
        test_end = test_start + testing_period

        # Train models on training data
        regime_detector.fit(price_data[train_start:train_end])
        position_sizer.calibrate(performance_data[train_start:train_end])
        factor_calculator.optimize(factor_data[train_start:train_end])

        # Test on out-of-sample data
        test_returns = strategy.backtest(test_start, test_end)
        results.append(test_returns)

    return aggregate_results(results)
```

**Regime-Aware Performance Attribution**
```python
class RegimePerformanceAttributor:
    def __init__(self, regime_detector):
        self.regime_detector = regime_detector
        self.regime_performance = {}

    def analyze_regime_performance(self, returns, regimes):
        """
        Break down performance by market regime
        """
        bull_returns = returns[regimes == 'bull']
        bear_returns = returns[regimes == 'bear']
        crisis_returns = returns[regimes == 'crisis']
        sideways_returns = returns[regimes == 'sideways']

        return {
            'bull': self.calculate_metrics(bull_returns),
            'bear': self.calculate_metrics(bear_returns),
            'crisis': self.calculate_metrics(crisis_returns),
            'sideways': self.calculate_metrics(sideways_returns)
        }

    def calculate_regime_transitions(self, regime_series):
        """
        Analyze performance during regime transitions
        """
        transition_points = self.detect_transitions(regime_series)
        transition_performance = []

        for transition in transition_points:
            # Analyze 10-day window around transition
            window_returns = self.get_transition_returns(transition)
            transition_performance.append(window_returns)

        return transition_performance
```

**Taiwan Market Transaction Cost Model**
```python
class TaiwanTransactionCostModel:
    def __init__(self):
        self.commission_rate = 0.001425  # 0.1425% brokerage fee
        self.tax_rate = 0.003           # 0.3% securities transaction tax
        self.min_commission = 20        # NT$20 minimum commission
        self.daily_limit = 0.10         # ±10% daily price limits

    def calculate_transaction_costs(self, trades_df):
        """
        Model realistic transaction costs including:
        - Commission fees (0.1425% with NT$20 minimum)
        - Securities transaction tax (0.3% on sales only)
        - Bid-ask spread modeling
        - Market impact for large orders
        - Daily limit impact on execution
        """
        total_costs = 0

        for _, trade in trades_df.iterrows():
            # Commission (both buy and sell)
            commission = max(trade.value * self.commission_rate, self.min_commission)

            # Tax (sell only)
            tax = trade.value * self.tax_rate if trade.side == 'sell' else 0

            # Bid-ask spread (Taiwan average ~0.05-0.15%)
            spread_cost = self.calculate_spread_cost(trade)

            # Market impact (for large orders)
            impact_cost = self.calculate_market_impact(trade)

            # Daily limit impact (delays and partial fills)
            limit_cost = self.calculate_limit_impact(trade)

            total_costs += commission + tax + spread_cost + impact_cost + limit_cost

        return total_costs

    def calculate_market_impact(self, trade):
        """
        Model market impact based on trade size vs average volume
        Taiwan market typically has higher impact for retail trades
        """
        volume_participation = trade.quantity / trade.avg_daily_volume

        if volume_participation > 0.10:  # >10% of daily volume
            impact = trade.value * 0.0020  # 20bps impact
        elif volume_participation > 0.05:  # 5-10% of daily volume
            impact = trade.value * 0.0010  # 10bps impact
        else:
            impact = trade.value * 0.0005  # 5bps impact

        return impact
```

### Advanced Analysis Components

**Performance Attribution Engine**
```python
class PerformanceAttributor:
    def __init__(self):
        self.factor_contributions = {}
        self.regime_contributions = {}
        self.position_sizing_contributions = {}

    def analyze_factor_contributions(self, returns, factor_exposures):
        """
        Decompose returns into factor contributions
        """
        # Factor-based attribution
        momentum_contribution = np.sum(returns * factor_exposures['momentum'])
        value_contribution = np.sum(returns * factor_exposures['value'])
        quality_contribution = np.sum(returns * factor_exposures['quality'])

        return {
            'momentum': momentum_contribution,
            'value': value_contribution,
            'quality': quality_contribution,
            'selection': returns.sum() - momentum_contribution - value_contribution - quality_contribution
        }

    def analyze_position_sizing_impact(self, returns, position_sizes, equal_weight_returns):
        """
        Measure impact of dynamic position sizing vs equal weight
        """
        dynamic_returns = np.sum(returns * position_sizes)
        equal_weight_benchmark = np.sum(equal_weight_returns * (1.0 / len(returns)))

        sizing_alpha = dynamic_returns - equal_weight_benchmark
        return sizing_alpha
```

**Risk Analysis Framework**
```python
class RiskAnalyzer:
    def __init__(self):
        self.risk_metrics = {}

    def calculate_risk_metrics(self, returns, benchmark_returns=None):
        """
        Comprehensive risk analysis including:
        - VaR and CVaR at multiple confidence levels
        - Maximum drawdown and drawdown duration
        - Regime-specific risk measures
        - Tail risk analysis
        """
        metrics = {}

        # Basic risk metrics
        metrics['volatility'] = returns.std() * np.sqrt(252)
        metrics['max_drawdown'] = self.calculate_max_drawdown(returns)
        metrics['sharpe_ratio'] = self.calculate_sharpe_ratio(returns)

        # VaR analysis
        metrics['var_95'] = np.percentile(returns, 5)
        metrics['var_99'] = np.percentile(returns, 1)
        metrics['cvar_95'] = returns[returns <= metrics['var_95']].mean()

        # Tail risk
        metrics['skewness'] = returns.skew()
        metrics['kurtosis'] = returns.kurtosis()
        metrics['tail_ratio'] = abs(metrics['cvar_95']) / metrics['volatility']

        # Benchmark comparison
        if benchmark_returns is not None:
            metrics['information_ratio'] = self.calculate_information_ratio(returns, benchmark_returns)
            metrics['tracking_error'] = (returns - benchmark_returns).std() * np.sqrt(252)
            metrics['beta'] = self.calculate_beta(returns, benchmark_returns)

        return metrics

    def analyze_drawdown_characteristics(self, returns):
        """
        Detailed drawdown analysis including:
        - Drawdown frequency and duration
        - Recovery time analysis
        - Underwater periods
        """
        cumulative = (1 + returns).cumprod()
        running_max = cumulative.expanding().max()
        drawdown = (cumulative - running_max) / running_max

        # Find drawdown periods
        drawdown_periods = []
        in_drawdown = False
        start_date = None

        for date, dd in drawdown.items():
            if dd < -0.01 and not in_drawdown:  # Start of drawdown (>1%)
                in_drawdown = True
                start_date = date
            elif dd >= -0.01 and in_drawdown:  # End of drawdown
                in_drawdown = False
                duration = (date - start_date).days
                max_dd = drawdown[start_date:date].min()
                drawdown_periods.append({
                    'start': start_date,
                    'end': date,
                    'duration': duration,
                    'max_drawdown': max_dd
                })

        return drawdown_periods
```

## Implementation Plan

### Phase 1: Core Backtesting Infrastructure (Week 1)

**Day 1-2: Base Backtesting Engine**
- Implement core backtesting framework with portfolio simulation
- Add position tracking and cash management
- Basic P&L calculation with transaction costs

**Day 3-4: Walk-Forward Analysis**
- Implement rolling window training/testing framework
- Add out-of-sample validation methodology
- Parameter stability testing across windows

**Day 5: Taiwan Market Integration**
- Add Taiwan-specific transaction cost modeling
- Implement daily price limit constraints
- Market impact and slippage modeling

### Phase 2: Advanced Analysis & Attribution (Week 2)

**Day 6-7: Performance Attribution**
- Factor-based performance decomposition
- Regime-aware performance analysis
- Position sizing impact measurement

**Day 8-9: Risk Analysis**
- Comprehensive risk metrics calculation
- Drawdown analysis and characteristics
- Tail risk and regime-specific risk measures

**Day 10: Validation & Testing**
- Compare backtest vs live trading accuracy
- Stress testing with historical crisis periods
- Performance validation across different time periods

### Phase 3: Integration & Optimization (Week 3)

**Day 11-12: Strategy Integration**
- Integrate with multi-regime strategy logic (Task 4)
- Add regime transition handling
- Portfolio rebalancing optimization

**Day 13-14: Reporting & Visualization**
- Comprehensive performance reports
- Regime-aware analytics dashboard
- Risk attribution and factor exposure analysis

**Day 15: Final Validation**
- End-to-end backtesting validation
- Performance vs target verification
- Documentation and testing completion

## Deliverables

### Core Implementation

**Enhanced Backtesting Engine**
```python
# /src/backtesting/enhanced_backtest_engine.py
class EnhancedBacktestEngine:
    def __init__(self, regime_detector, position_sizer, factor_calculator, strategy):
        self.regime_detector = regime_detector
        self.position_sizer = position_sizer
        self.factor_calculator = factor_calculator
        self.strategy = strategy
        self.transaction_cost_model = TaiwanTransactionCostModel()
        self.performance_attributor = PerformanceAttributor()

    def run_walk_forward_backtest(self, start_date, end_date, parameters):
        """Execute walk-forward backtesting with parameter optimization"""

    def analyze_regime_performance(self, results):
        """Analyze performance across different market regimes"""

    def generate_comprehensive_report(self, results):
        """Generate detailed performance and risk analysis report"""
```

**Walk-Forward Analysis Framework**
```python
# /src/backtesting/walk_forward_analyzer.py
class WalkForwardAnalyzer:
    def __init__(self, train_window=252*3, test_window=252, step_size=21):
        self.train_window = train_window
        self.test_window = test_window
        self.step_size = step_size

    def generate_windows(self, start_date, end_date):
        """Generate training/testing windows for walk-forward analysis"""

    def validate_parameter_stability(self, parameter_history):
        """Analyze parameter stability across windows"""

    def calculate_out_of_sample_metrics(self, oos_results):
        """Calculate comprehensive out-of-sample performance metrics"""
```

**Transaction Cost & Market Impact Model**
```python
# /src/backtesting/taiwan_transaction_costs.py
class TaiwanTransactionCostModel:
    def __init__(self):
        self.commission_schedule = self.load_commission_schedule()
        self.tax_schedule = self.load_tax_schedule()
        self.market_impact_model = self.initialize_impact_model()

    def calculate_total_transaction_costs(self, trades_df):
        """Calculate comprehensive transaction costs for Taiwan market"""

    def model_execution_delays(self, trades_df, market_data):
        """Model execution delays due to daily limits and liquidity"""

    def estimate_market_impact(self, trade_size, stock_liquidity):
        """Estimate market impact based on trade size and stock characteristics"""
```

### Configuration & Parameters

**Backtesting Configuration**
```yaml
# /config/enhanced_backtesting_config.yml
walk_forward:
  train_window_years: 3          # Training period length
  test_window_years: 1           # Testing period length
  step_size_days: 21             # Monthly roll-forward
  min_observations: 504          # Minimum data points (2 years)
  parameter_stability_threshold: 0.15  # Max parameter drift

transaction_costs:
  commission_rate: 0.001425      # Taiwan brokerage commission
  tax_rate: 0.003               # Securities transaction tax
  min_commission: 20            # Minimum commission (NT$)
  spread_model: "adaptive"       # Bid-ask spread modeling
  impact_model: "taiwan_retail"  # Market impact model

regime_analysis:
  attribution_method: "factor_based"
  transition_window: 10          # Days around regime transitions
  min_regime_duration: 20        # Minimum regime length for analysis

risk_analysis:
  var_confidence_levels: [0.95, 0.99]
  drawdown_threshold: 0.01       # 1% minimum drawdown
  tail_risk_percentile: 0.05     # 5% tail for extreme events
  stress_test_scenarios: ["2008_crisis", "2020_covid", "2018_trade_war"]
```

### Testing Framework

**Backtesting Validation Tests**
```python
# /tests/backtesting/test_enhanced_backtest_engine.py
class TestEnhancedBacktestEngine:
    def test_walk_forward_accuracy(self):
        """Test walk-forward backtest accuracy vs benchmark"""

    def test_transaction_cost_modeling(self):
        """Validate Taiwan transaction cost calculations"""

    def test_regime_performance_attribution(self):
        """Test regime-aware performance analysis"""

    def test_risk_metrics_calculation(self):
        """Validate risk metrics and drawdown analysis"""

    def test_parameter_stability(self):
        """Test parameter stability across walk-forward windows"""

# /tests/backtesting/test_integration.py
class TestBacktestingIntegration:
    def test_full_strategy_integration(self):
        """Test integration with all Layer 1 components"""

    def test_historical_crisis_periods(self):
        """Test performance during known crisis periods"""

    def test_regime_transition_handling(self):
        """Test backtesting during regime transitions"""
```

**Performance Benchmarks**
```python
# Expected backtest improvements:
backtest_benchmarks = {
    'accuracy_vs_live': 0.95,        # 95% correlation with live results
    'parameter_stability': 0.85,     # 85% parameter consistency
    'risk_prediction': 0.90,         # 90% risk metric accuracy
    'regime_attribution': 0.80       # 80% regime performance accuracy
}
```

## Success Criteria

### Accuracy & Validation
- ✅ **Walk-Forward Accuracy**: >95% correlation between backtest and live trading results
- ✅ **Parameter Stability**: <15% parameter drift across walk-forward windows
- ✅ **Risk Prediction**: Risk metrics predict actual risk within 10% accuracy
- ✅ **Transaction Cost**: Modeled costs within 5% of actual trading costs

### Performance Analysis
- ✅ **Regime Attribution**: Accurately decompose performance by market regime
- ✅ **Factor Attribution**: Identify contribution of each enhanced factor
- ✅ **Position Sizing Impact**: Quantify dynamic sizing vs equal weight benefits
- ✅ **Crisis Performance**: Validate strategy behavior during historical crises

### Integration Success
- ✅ **Component Integration**: Seamless integration with all Layer 1 components
- ✅ **Reporting Completeness**: Comprehensive performance and risk reports
- ✅ **Validation Framework**: Robust testing across multiple time periods
- ✅ **Documentation**: Complete documentation of methodology and results

## Integration Points

### Upstream Dependencies
- **Task 1**: Regime detection results for regime-aware analysis
- **Task 2**: Dynamic position sizing for attribution analysis
- **Task 3**: Enhanced factors for factor-based attribution
- **Task 4**: Multi-regime strategy for complete backtesting

### Downstream Integration
- **Task 6**: Historical validation will use this backtesting framework
- **Task 7**: Real-time monitoring will compare against backtest predictions
- **Task 8**: Parameter optimization will use walk-forward results

### Data Flow Integration
```
Historical Market Data
    ↓
Walk-Forward Analysis Framework
    ↓
Layer 1 Components (Regime, Sizing, Factors, Strategy)
    ↓
Enhanced Backtesting Engine
    ↓
Performance & Risk Attribution
    ↓
Comprehensive Analysis Reports
```

## Risk Management

### Backtesting Risks
- **Overfitting Risk**: Excessive parameter optimization may reduce out-of-sample performance
  - *Mitigation*: Strict walk-forward methodology, parameter stability monitoring
- **Look-Ahead Bias**: Using future information in historical analysis
  - *Mitigation*: Point-in-time data, careful timestamp management

### Model Risks
- **Regime Detection Lag**: Regime changes may not be detected immediately
  - *Mitigation*: Regime transition analysis, adaptive detection thresholds
- **Transaction Cost Underestimation**: Modeled costs may be lower than reality
  - *Mitigation*: Conservative cost assumptions, regular calibration with live data

### Implementation Risks
- **Data Quality**: Historical data errors affect backtesting accuracy
  - *Mitigation*: Data validation checks, multiple data source verification
- **Computational Complexity**: Walk-forward analysis may be resource intensive
  - *Mitigation*: Efficient algorithms, parallel processing, incremental updates

## Taiwan Market Context

### Market Structure Considerations
- **High Retail Participation**: 85%+ retail volume affects transaction costs and market impact
- **Technology Concentration**: Regime analysis must account for tech sector dominance
- **Daily Price Limits**: ±10% limits affect execution timing and slippage
- **T+2 Settlement**: Settlement timing affects position management and cash requirements

### Historical Backtesting Periods
- **2014-2017 Tech Boom**: Test momentum strategies and position sizing
- **2018-2019 Trade War**: Validate regime detection and crisis management
- **2020 COVID Crisis**: Test extreme volatility and drawdown management
- **2021-2022 Recovery**: Validate regime transitions and factor stability
- **2023-2024 Normalization**: Test current strategy effectiveness

### Regulatory Considerations
- **Position Limits**: Individual stock and sector concentration limits
- **Reporting Requirements**: Large position disclosure affects strategy execution
- **Market Access**: Retail vs institutional access differences
- **Tax Implications**: Transaction tax and dividend tax considerations

## Future Enhancements

### Advanced Analytics
- **Machine Learning Attribution**: ML-based performance decomposition
- **Regime Prediction**: Predictive regime modeling for forward-looking analysis
- **Alternative Data Integration**: News sentiment, macro data backtesting
- **Cross-Asset Analysis**: Currency and bond market impact on equity strategy

### Real-Time Integration
- **Live Backtesting**: Real-time strategy validation against backtest predictions
- **Adaptive Parameters**: Dynamic parameter adjustment based on regime changes
- **Performance Monitoring**: Continuous comparison of live vs backtest performance
- **Alert System**: Automated alerts when performance deviates from expectations

### Optimization Features
- **Genetic Algorithm Optimization**: Advanced parameter optimization techniques
- **Multi-Objective Optimization**: Balance return, risk, and transaction costs
- **Robust Optimization**: Parameter selection for uncertain market conditions
- **Portfolio Construction**: Enhanced portfolio optimization with backtesting feedback